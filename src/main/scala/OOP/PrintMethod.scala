package OOP

object PrintMethod extends App{
  // задача: напечатать имя в консоль

  class User(val name: String) // класс, у которого поле name доступно для вызова на экземпляре - val
  val admin = new User("Grisha") // создание экземпляра
  println(admin.name) // тут мы обращаемся к полю name и печатаем его в консоль.


  // убрать val - одна из 3х столбов - инкапсуляция
  class UserWithoutVal(name: String) { // класс, у которого поле name не имеет val и по этому мы не можем его получить и напечатоть
    def printName: Unit = {  // метод печатает имя и поскольку нам от него больше ничего не нужно то его результат пустота. Можно сказать что метод возвращает Unit
      // поскольку name доступен внутри класса, то мы можем сделать метод, внутри которого он доступен
      // и тем самым мы можем распечатать его имя в консоль
      println(name)
    }
  }
  val adminWithoutVal = new UserWithoutVal("Grisha") // создание экземпляра
  adminWithoutVal.printName // вызов метода, который вернет пустоту. Наша цель напечатать в консоль и мы ее достигли


  class UserWithoutValAndPrint(name: String){ // использовать println внутри клсса плохая практика, по этому запрещаем так делать сами себе
    def getName: String = { // тут метод не печатает, а только возвращает имя. Имя недоступно из вне класса, но жоступно в середине метода
      name //возвращает строку и именем. Возврат - это всегда посл строчка но перед ней могут быть вычисления, например метод возвращает Double когда мы считаем сумму нескольких элементов
    }
  }
  val adminWithoutValAndPrint = new UserWithoutValAndPrint("Grisha")// создание экземпляра
  println(adminWithoutValAndPrint.getName) // вызываем метод, который возвращает строку с именем и мы тут же ее передаем на печать.
  // Но никто не запрещает считать имя в переменную, например val someName:String = adminWithoutValAndPrint.getName
}
